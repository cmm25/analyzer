import { ASTNode } from "../parser/solidity";
import { ASTNodeWithLocation, findNodes } from "./astUtils";

/**
 * Finds external calls within a node that might lead to reentrancy.
 * This includes calls to external contracts or functions that transfer Ether.
 */
export function findExternalCalls(node: ASTNode): ASTNodeWithLocation[] {
    const externalCalls: ASTNodeWithLocation[] = [];

    function traverse(subNode: ASTNode) {
        if (!subNode) return;

        // Check for external calls like address.call, address.send, address.transfer
        if (
            subNode.type === "MemberAccess" &&
            subNode.memberName &&
            ["call", "delegatecall", "staticcall", "send", "transfer"].includes(
                subNode.memberName
            )
        ) {
            externalCalls.push(subNode as ASTNodeWithLocation);
        }

        // Check for low-level calls like address.call{value: amount}("")
        if (
            subNode.type === "FunctionCall" &&
            subNode.expression &&
            subNode.expression.type === "MemberAccess" &&
            ["call", "delegatecall", "staticcall"].includes(
                subNode.expression.memberName
            )
        ) {
            externalCalls.push(subNode as ASTNodeWithLocation);
        }

        // Check for external function calls to other contracts
        if (
            subNode.type === "FunctionCall" &&
            subNode.expression &&
            subNode.expression.type === "MemberAccess" &&
            subNode.expression.expression &&
            subNode.expression.expression.type !== "ThisExpression"
        ) {
            // This is a potential external call if it's not calling a function on 'this'
            externalCalls.push(subNode as ASTNodeWithLocation);
        }

        // Traverse children
        for (const key in subNode) {
            if (typeof subNode[key] === "object" && subNode[key] !== null) {
                if (Array.isArray(subNode[key])) {
                    subNode[key].forEach(traverse);
                } else {
                    traverse(subNode[key]);
                }
            }
        }
    }

    traverse(node);
    return externalCalls;
}

/**
 * Finds state changes within a node (like assignments to state variables)
 * that could be problematic in a reentrancy attack.
 */
export function findStateChanges(node: ASTNode): ASTNodeWithLocation[] {
    const stateChanges: ASTNodeWithLocation[] = [];

    function traverse(subNode: ASTNode) {
        if (!subNode) return;

        // Check for assignments to state variables
        if (subNode.type === "Assignment") {
            stateChanges.push(subNode as ASTNodeWithLocation);
        }

        // Check for state variable updates within expressions
        if (
            subNode.type === "UnaryOperation" &&
            (subNode.operator === "++" || subNode.operator === "--")
        ) {
            stateChanges.push(subNode as ASTNodeWithLocation);
        }

        // Check for delete operations on state variables
        if (subNode.type === "UnaryOperation" && subNode.operator === "delete") {
            stateChanges.push(subNode as ASTNodeWithLocation);
        }

        // Traverse children
        for (const key in subNode) {
            if (typeof subNode[key] === "object" && subNode[key] !== null) {
                if (Array.isArray(subNode[key])) {
                    subNode[key].forEach(traverse);
                } else {
                    traverse(subNode[key]);
                }
            }
        }
    }

    traverse(node);
    return stateChanges;
}

/**
 * Checks if a function is vulnerable to reentrancy.
 */
export function isVulnerableToReentrancy(functionNode: ASTNode): boolean {
    const externalCalls = findExternalCalls(functionNode);
    const stateChanges = findStateChanges(functionNode);

    if (externalCalls.length === 0 || stateChanges.length === 0) {
        return false;
    }

    // Sort by source position
    const nodesByPosition: ASTNodeWithLocation[] = [
        ...externalCalls,
        ...stateChanges,
    ]
        .filter((node) => node.loc && node.loc.start)
        .sort((a, b) => {
            const aLine = a.loc?.start.line || 0;
            const bLine = b.loc?.start.line || 0;

            if (aLine === bLine) {
                return (a.loc?.start.column || 0) - (b.loc?.start.column || 0);
            }

            return aLine - bLine;
        });

    // Check if there are any state changes after external calls
    // This is the pattern that makes a function vulnerable to reentrancy
    for (let i = 0; i < nodesByPosition.length - 1; i++) {
        const currentNode = nodesByPosition[i];

        // If we find an external call
        if (externalCalls.includes(currentNode)) {
            // Check if any state changes come after it
            for (let j = i + 1; j < nodesByPosition.length; j++) {
                if (stateChanges.includes(nodesByPosition[j])) {
                    // We found a state change after an external call - potential reentrancy vulnerability
                    return true;
                }
            }
        }
    }

    // Check for presence of reentrancy guard
    const hasReentrancyGuard =
        functionNode.modifiers &&
        functionNode.modifiers.some(
            (mod: any) =>
                mod.name &&
                ["nonReentrant", "noReentrant", "reentrancyGuard"].includes(mod.name)
        );

    // If function has a reentrancy guard, it's less likely to be vulnerable
    if (hasReentrancyGuard) {
        return false;
    }

    return false; // No vulnerable pattern detected
}

/**
 * Identifies functions that might be vulnerable to unchecked send/call return values.
 */
export function hasUncheckedCallReturn(functionNode: ASTNode): boolean {
    let uncheckedCalls = false;

    function traverse(node: ASTNode, isInCondition = false) {
        if (!node) return;

        // If we're in a condition, any calls inside are considered checked
        if (isInCondition) {
            // Simple traversal without checking for calls
            for (const key in node) {
                if (typeof node[key] === "object" && node[key] !== null) {
                    if (Array.isArray(node[key])) {
                        node[key].forEach((child) => traverse(child, true));
                    } else {
                        traverse(node[key], true);
                    }
                }
            }
            return;
        }

        // Check if node is a condition (if statement, require, etc.)
        const isCondition = [
            "IfStatement",
            "WhileStatement",
            "DoWhileStatement",
            "Conditional",
        ].includes(node.type);

        // Check for calls that might be unchecked
        if (
            node.type === "FunctionCall" &&
            node.expression &&
            node.expression.type === "MemberAccess" &&
            ["call", "send"].includes(node.expression.memberName)
        ) {
            // If a call is not inside a condition (like if/require), it might be unchecked
            if (!isCondition) {
                // Check if it's assigned to a variable and then checked later
                const parent = node.parent; // This would require a parent reference in the AST
                if (!parent || parent.type !== "VariableDeclaration") {
                    uncheckedCalls = true;
                }
            }
        }

        // Traverse children with appropriate isInCondition flag
        for (const key in node) {
            if (typeof node[key] === "object" && node[key] !== null) {
                if (Array.isArray(node[key])) {
                    node[key].forEach((child) =>
                        traverse(child, isCondition || isInCondition)
                    );
                } else {
                    traverse(node[key], isCondition || isInCondition);
                }
            }
        }
    }

    traverse(functionNode);
    return uncheckedCalls;
}
