import { ASTNode } from "../parser/solidity";
import { ASTNodeWithLocation, findNodes } from "./astUtils";

/**
 * Finds external calls within a node that might lead to reentrancy.
 * This includes calls to external contracts or functions that transfer Ether.
 */
export function findExternalCalls(node: ASTNode): ASTNodeWithLocation[] {
    const externalCalls: ASTNodeWithLocation[] = [];

    function traverse(subNode: ASTNode) {
        if (!subNode) return;

        // Check for external calls like address.call, address.send, address.transfer
        if (
            subNode.type === "MemberAccess" &&
            subNode.memberName &&
            ["call", "delegatecall", "staticcall", "send", "transfer"].includes(
                subNode.memberName
            )
        ) {
            externalCalls.push(subNode as ASTNodeWithLocation);
        }

        if (
            subNode.type === "FunctionCall" &&
            subNode.expression &&
            subNode.expression.type === "MemberAccess" &&
            ["call", "delegatecall", "staticcall"].includes(
                subNode.expression.memberName
            )
        ) {
            externalCalls.push(subNode as ASTNodeWithLocation);
        }

        // Check for external function calls to other contracts
        if (
            subNode.type === "FunctionCall" &&
            subNode.expression &&
            subNode.expression.type === "MemberAccess" &&
            subNode.expression.expression &&
            subNode.expression.expression.type !== "ThisExpression"
        ) {
            externalCalls.push(subNode as ASTNodeWithLocation);
        }

        // Traverse children
        for (const key in subNode) {
            if (typeof subNode[key] === "object" && subNode[key] !== null) {
                if (Array.isArray(subNode[key])) {
                    subNode[key].forEach(traverse);
                } else {
                    traverse(subNode[key]);
                }
            }
        }
    }

    traverse(node);
    return externalCalls;
}

export function findStateChanges(node: ASTNode): ASTNodeWithLocation[] {
    const stateChanges: ASTNodeWithLocation[] = [];

    function traverse(subNode: ASTNode) {
        if (!subNode) return;
        if (subNode.type === "Assignment") {  stateChanges.push(subNode as ASTNodeWithLocation); }
        if (
            subNode.type === "UnaryOperation" &&
            (subNode.operator === "++" || subNode.operator === "--")
        ) {
            stateChanges.push(subNode as ASTNodeWithLocation);
        }
        if (subNode.type === "UnaryOperation" && subNode.operator === "delete") {
            stateChanges.push(subNode as ASTNodeWithLocation);
        }
        for (const key in subNode) {
            if (typeof subNode[key] === "object" && subNode[key] !== null) {
                if (Array.isArray(subNode[key])) {
                    subNode[key].forEach(traverse);
                } else {
                    traverse(subNode[key]);
                }
            }
        }
    }

    traverse(node);
    return stateChanges;
}

export function isVulnerableToReentrancy(functionNode: ASTNode): boolean {
    const externalCalls = findExternalCalls(functionNode);
    const stateChanges = findStateChanges(functionNode);

    if (externalCalls.length === 0 || stateChanges.length === 0) {
        return false;
    }

    // Sort by source position
    const nodesByPosition: ASTNodeWithLocation[] = [
        ...externalCalls,
        ...stateChanges,
    ]
        .filter((node) => node.loc && node.loc.start)
        .sort((a, b) => {
            const aLine = a.loc?.start.line || 0;
            const bLine = b.loc?.start.line || 0;

            if (aLine === bLine) {
                return (a.loc?.start.column || 0) - (b.loc?.start.column || 0);
            }

            return aLine - bLine;
        });
    for (let i = 0; i < nodesByPosition.length - 1; i++) {
        const currentNode = nodesByPosition[i];

        if (externalCalls.includes(currentNode)) {
            for (let j = i + 1; j < nodesByPosition.length; j++) {
                if (stateChanges.includes(nodesByPosition[j])) {
                    return true;
                }
            }
        }
    }
    const hasReentrancyGuard =
        functionNode.modifiers &&
        functionNode.modifiers.some(
            (mod: any) =>
                mod.name &&
                ["nonReentrant", "noReentrant", "reentrancyGuard"].includes(mod.name)
        );
    if (hasReentrancyGuard) {
        return false;
    }

    return false;
}

export function hasUncheckedCallReturn(functionNode: ASTNode): boolean {
    let uncheckedCalls = false;

    function traverse(node: ASTNode, isInCondition = false) {
        if (!node) return;
        if (isInCondition) {
            for (const key in node) {
                if (typeof node[key] === "object" && node[key] !== null) {
                    if (Array.isArray(node[key])) {
                        node[key].forEach((child) => traverse(child, true));
                    } else {
                        traverse(node[key], true);
                    }
                }
            }
            return;
        }

        const isCondition = [
            "IfStatement",
            "WhileStatement",
            "DoWhileStatement",
            "Conditional",
        ].includes(node.type);
        if (
            node.type === "FunctionCall" &&
            node.expression &&
            node.expression.type === "MemberAccess" &&
            ["call", "send"].includes(node.expression.memberName)
        ) {
            if (!isCondition) {
                const parent = node.parent; 
                if (!parent || parent.type !== "VariableDeclaration") {
                    uncheckedCalls = true;
                }
            }
        }

        for (const key in node) {
            if (typeof node[key] === "object" && node[key] !== null) {
                if (Array.isArray(node[key])) {
                    node[key].forEach((child) =>
                        traverse(child, isCondition || isInCondition)
                    );
                } else {
                    traverse(node[key], isCondition || isInCondition);
                }
            }
        }
    }

    traverse(functionNode);
    return uncheckedCalls;
}
