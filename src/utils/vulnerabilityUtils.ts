import { ASTNode } from "../parser/solidity";
import { ASTNodeWithLocation, findNodes } from "./astUtils";

/**
 * Finds all nodes in the AST that match the given predicate
 * @param node The root AST node to search
 * @param predicate A function that returns true for nodes that should be included
 * @returns Array of matching nodes
 */
export function findAll(node: ASTNode, predicate: (node: ASTNode) => boolean): ASTNodeWithLocation[] {
    const result: ASTNodeWithLocation[] = [];
    
    function traverse(currentNode: ASTNode) {
        if (!currentNode) return;
        
        if (predicate(currentNode)) {
            result.push(currentNode as ASTNodeWithLocation);
        }
        
        // Traverse children
        for (const key in currentNode) {
            const child = (currentNode as any)[key];
            
            if (child && typeof child === 'object') {
                // If it's an array, traverse each item
                if (Array.isArray(child)) {
                    for (const item of child) {
                        if (item && typeof item === 'object') {
                            traverse(item);
                        }
                    }
                } 
                // If it has a type property, it's likely an AST node
                else if (child.type) {
                    traverse(child);
                }
            }
        }
    }
    
    traverse(node);
    return result;
}

export function findExternalCalls(node: ASTNode): ASTNodeWithLocation[] {
    const externalCalls: ASTNodeWithLocation[] = [];

    function traverse(subNode: ASTNode) {
        if (!subNode) return;

        // Check for external calls like address.call, address.send, address.transfer
        if (
            subNode.type === "MemberAccess" &&
            subNode.memberName &&
            ["call", "delegatecall", "staticcall", "send", "transfer"].includes(
                subNode.memberName
            )
        ) {
            externalCalls.push(subNode as ASTNodeWithLocation);
        }

        if (
            subNode.type === "FunctionCall" &&
            subNode.expression &&
            subNode.expression.type === "MemberAccess" &&
            ["call", "delegatecall", "staticcall"].includes(
                subNode.expression.memberName
            )
        ) {
            externalCalls.push(subNode as ASTNodeWithLocation);
        }

        // Check for external function calls to other contracts
        if (
            subNode.type === "FunctionCall" &&
            subNode.expression &&
            subNode.expression.type === "MemberAccess" &&
            subNode.expression.expression &&
            subNode.expression.expression.type !== "ThisExpression"
        ) {
            externalCalls.push(subNode as ASTNodeWithLocation);
        }

        // Traverse children
        for (const key in subNode) {
            if (typeof subNode[key] === "object" && subNode[key] !== null) {
                if (Array.isArray(subNode[key])) {
                    subNode[key].forEach(traverse);
                } else {
                    traverse(subNode[key]);
                }
            }
        }
    }

    traverse(node);
    return externalCalls;
}

export function findStateChanges(node: ASTNode): ASTNodeWithLocation[] {
    const stateChanges: ASTNodeWithLocation[] = [];

    function traverse(subNode: ASTNode) {
        if (!subNode) return;
        if (subNode.type === "Assignment") {  stateChanges.push(subNode as ASTNodeWithLocation); }
        if (
            subNode.type === "UnaryOperation" &&
            (subNode.operator === "++" || subNode.operator === "--")
        ) {
            stateChanges.push(subNode as ASTNodeWithLocation);
        }
        if (subNode.type === "UnaryOperation" && subNode.operator === "delete") {
            stateChanges.push(subNode as ASTNodeWithLocation);
        }
        for (const key in subNode) {
            if (typeof subNode[key] === "object" && subNode[key] !== null) {
                if (Array.isArray(subNode[key])) {
                    subNode[key].forEach(traverse);
                } else {
                    traverse(subNode[key]);
                }
            }
        }
    }

    traverse(node);
    return stateChanges;
}

export function isVulnerableToReentrancy(functionNode: ASTNode): boolean {
    const externalCalls = findExternalCalls(functionNode);
    const stateChanges = findStateChanges(functionNode);

    if (externalCalls.length === 0 || stateChanges.length === 0) {
        return false;
    }
    const nodesByPosition: ASTNodeWithLocation[] = [
        ...externalCalls,
        ...stateChanges,
    ]
        .filter((node) => node.loc && node.loc.start)
        .sort((a, b) => {
            const aLine = a.loc?.start.line || 0;
            const bLine = b.loc?.start.line || 0;

            if (aLine === bLine) {
                return (a.loc?.start.column || 0) - (b.loc?.start.column || 0);
            }

            return aLine - bLine;
        });
    for (let i = 0; i < nodesByPosition.length - 1; i++) {
        const currentNode = nodesByPosition[i];

        if (externalCalls.includes(currentNode)) {
            for (let j = i + 1; j < nodesByPosition.length; j++) {
                if (stateChanges.includes(nodesByPosition[j])) {
                    return true;
                }
            }
        }
    }
    const hasReentrancyGuard =
        functionNode.modifiers &&
        functionNode.modifiers.some(
            (mod: any) =>
                mod.name &&
                ["nonReentrant", "noReentrant", "reentrancyGuard"].includes(mod.name)
        );
    if (hasReentrancyGuard) {
        return false;
    }

    return false;
}

export function hasUncheckedCallReturn(functionNode: ASTNode): boolean {
    let uncheckedCalls = false;

    function traverse(node: ASTNode, isInCondition = false) {
        if (!node) return;
        if (isInCondition) {
            for (const key in node) {
                if (typeof node[key] === "object" && node[key] !== null) {
                    if (Array.isArray(node[key])) {
                        node[key].forEach((child) => traverse(child, true));
                    } else {
                        traverse(node[key], true);
                    }
                }
            }
            return;
        }

        const isCondition = [
            "IfStatement",
            "WhileStatement",
            "DoWhileStatement",
            "Conditional",
        ].includes(node.type);
        if (
            node.type === "FunctionCall" &&
            node.expression &&
            node.expression.type === "MemberAccess" &&
            ["call", "send"].includes(node.expression.memberName)
        ) {
            if (!isCondition) {
                const parent = node.parent; 
                if (!parent || parent.type !== "VariableDeclaration") {
                    uncheckedCalls = true;
                }
            }
        }

        for (const key in node) {
            if (typeof node[key] === "object" && node[key] !== null) {
                if (Array.isArray(node[key])) {
                    node[key].forEach((child) =>
                        traverse(child, isCondition || isInCondition)
                    );
                } else {
                    traverse(node[key], isCondition || isInCondition);
                }
            }
        }
    }

    traverse(functionNode);
    return uncheckedCalls;
}
